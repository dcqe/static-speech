{"ast":null,"code":"/**\n * Filter Config\n *\n * Stores the main filter config object and exports a bunch of\n * utility functions to help work with it. A 'filter' can exist in\n * two distinct forms;\n *\n * * An intention from the user (e.g. in their options)\n * * A filter that is ready to be applied\n *\n * In this config, the key is the \"rule\" and filters can have the\n * following properties;\n *\n * label: The human-readable label to display for this filter\n * dialogComponent: (optional) Dialog associated with filter\n * buildFilter: Function for constructing a filter from user options\n *\n * the `buildFilter` function of each filter config entry will be\n * passed two arguments;\n *\n * - the user filter options\n * - the rest of the state\n *\n * it should  return an object representing the filter rule to apply.\n * At the very least this needs to specify a \"rule\" property - this\n * will be used to determine which function to  call in `filterRules`\n * in order to actually apply the filter.\n *\n */\nimport { keys, get } from \"lodash\";\nimport { GlassFilterDialog, CategoryFilterDialog, IngredientFilterDialog } from \"./components/Filters\";\n/**\n * Main filter config object\n */\n\nconst filterConfig = {\n  byIngredient: {\n    dialogComponent: IngredientFilterDialog,\n    label: \"By Ingredient...\",\n    buildFilter: ({\n      ingredientsRule,\n      ingredients\n    }) => ({\n      rule: ingredientsRule,\n      ingredients\n    })\n  },\n  byCategory: {\n    dialogComponent: CategoryFilterDialog,\n    label: \"By Category...\",\n    buildFilter: ({\n      categories\n    }) => ({\n      rule: \"inCategory\",\n      categories\n    })\n  },\n  byGlass: {\n    dialogComponent: GlassFilterDialog,\n    label: \"By Glass...\",\n    buildFilter: ({\n      glasses\n    }) => ({\n      rule: \"inGlass\",\n      glasses\n    })\n  },\n  barOnly: {\n    label: \"Makeable from Bar\",\n    buildFilter: (_, {\n      bar\n    }) => ({\n      rule: \"makeableFrom\",\n      ingredients: bar\n    })\n  },\n  favouritesOnly: {\n    label: \"Favourites only\",\n    buildFilter: (_, {\n      favourites\n    }) => ({\n      rule: \"isFavourite\",\n      favourites\n    })\n  },\n  veganOnly: {\n    label: \"Vegan only\",\n    buildFilter: () => ({\n      rule: \"mustHaveTruthyProperty\",\n      property: \"vegan\"\n    })\n  },\n  ibaOnly: {\n    label: \"IBA only\",\n    buildFilter: () => ({\n      rule: \"mustHaveTruthyProperty\",\n      property: \"iba\"\n    })\n  }\n};\n\nfunction getFilterConfig(filterRule) {\n  return filterConfig[filterRule && filterRule.toString()];\n} // Fishes out the label for a filter rule (if there is one)\n\n\nexport function labelFor(filterRule) {\n  return get(getFilterConfig(filterRule), \"label\") || filterRule;\n} // Fishes out the custom dialog for a filter rule (if there is one)\n\nexport function dialogFor(filterRule) {\n  return get(getFilterConfig(filterRule), \"dialogComponent\");\n} // Returns true if this filter rule has a custom dialog\n\nexport function hasDialog(filterRule) {\n  return !!dialogFor(filterRule);\n} // HoF for building the actual filters that will be applied from\n// user options.\n\nexport function buildFilter(filterRule) {\n  return get(getFilterConfig(filterRule), \"buildFilter\");\n} // Returns a list of the rules\n\nexport function getRules() {\n  return keys(filterConfig);\n}","map":{"version":3,"sources":["/home/students/ge47qut/public_html/v2/react-speech/src/filterConfig.js"],"names":["keys","get","GlassFilterDialog","CategoryFilterDialog","IngredientFilterDialog","filterConfig","byIngredient","dialogComponent","label","buildFilter","ingredientsRule","ingredients","rule","byCategory","categories","byGlass","glasses","barOnly","_","bar","favouritesOnly","favourites","veganOnly","property","ibaOnly","getFilterConfig","filterRule","toString","labelFor","dialogFor","hasDialog","getRules"],"mappings":"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","sourcesContent":["/**\n * Filter Config\n *\n * Stores the main filter config object and exports a bunch of\n * utility functions to help work with it. A 'filter' can exist in\n * two distinct forms;\n *\n * * An intention from the user (e.g. in their options)\n * * A filter that is ready to be applied\n *\n * In this config, the key is the \"rule\" and filters can have the\n * following properties;\n *\n * label: The human-readable label to display for this filter\n * dialogComponent: (optional) Dialog associated with filter\n * buildFilter: Function for constructing a filter from user options\n *\n * the `buildFilter` function of each filter config entry will be\n * passed two arguments;\n *\n * - the user filter options\n * - the rest of the state\n *\n * it should  return an object representing the filter rule to apply.\n * At the very least this needs to specify a \"rule\" property - this\n * will be used to determine which function to  call in `filterRules`\n * in order to actually apply the filter.\n *\n */\nimport { keys, get } from \"lodash\";\n\nimport {\n  GlassFilterDialog,\n  CategoryFilterDialog,\n  IngredientFilterDialog\n} from \"./components/Filters\";\n\n/**\n * Main filter config object\n */\nconst filterConfig = {\n  byIngredient: {\n    dialogComponent: IngredientFilterDialog,\n    label: \"By Ingredient...\",\n    buildFilter: ({ ingredientsRule, ingredients }) => ({\n      rule: ingredientsRule,\n      ingredients\n    })\n  },\n  byCategory: {\n    dialogComponent: CategoryFilterDialog,\n    label: \"By Category...\",\n    buildFilter: ({ categories }) => ({\n      rule: \"inCategory\",\n      categories\n    })\n  },\n  byGlass: {\n    dialogComponent: GlassFilterDialog,\n    label: \"By Glass...\",\n    buildFilter: ({ glasses }) => ({\n      rule: \"inGlass\",\n      glasses\n    })\n  },\n  barOnly: {\n    label: \"Makeable from Bar\",\n    buildFilter: (_, { bar }) => ({\n      rule: \"makeableFrom\",\n      ingredients: bar\n    })\n  },\n  favouritesOnly: {\n    label: \"Favourites only\",\n    buildFilter: (_, { favourites }) => ({\n      rule: \"isFavourite\",\n      favourites\n    })\n  },\n  veganOnly: {\n    label: \"Vegan only\",\n    buildFilter: () => ({\n      rule: \"mustHaveTruthyProperty\",\n      property: \"vegan\"\n    })\n  },\n  ibaOnly: {\n    label: \"IBA only\",\n    buildFilter: () => ({\n      rule: \"mustHaveTruthyProperty\",\n      property: \"iba\"\n    })\n  }\n};\n\nfunction getFilterConfig(filterRule) {\n  return filterConfig[filterRule && filterRule.toString()];\n}\n\n// Fishes out the label for a filter rule (if there is one)\nexport function labelFor(filterRule) {\n  return get(getFilterConfig(filterRule), \"label\") || filterRule;\n}\n\n// Fishes out the custom dialog for a filter rule (if there is one)\nexport function dialogFor(filterRule) {\n  return get(getFilterConfig(filterRule), \"dialogComponent\");\n}\n\n// Returns true if this filter rule has a custom dialog\nexport function hasDialog(filterRule) {\n  return !!dialogFor(filterRule);\n}\n\n// HoF for building the actual filters that will be applied from\n// user options.\nexport function buildFilter(filterRule) {\n  return get(getFilterConfig(filterRule), \"buildFilter\");\n}\n\n// Returns a list of the rules\nexport function getRules() {\n  return keys(filterConfig);\n}\n"]},"metadata":{},"sourceType":"module"}