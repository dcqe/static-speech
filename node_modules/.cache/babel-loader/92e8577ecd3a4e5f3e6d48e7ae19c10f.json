{"ast":null,"code":"import _objectWithoutProperties from\"/home/students/ge47qut/public_html/v2/react-speech/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";import _toConsumableArray from\"/home/students/ge47qut/public_html/v2/react-speech/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import compact from\"lodash/compact\";import isArray from\"lodash/isArray\";import{buildFilter}from\"../filterConfig\";import*as rules from\"./filterRules\";/**\n * Apply a single filter to a set of cocktails\n * @param {*} cocktails\n * @param {*} filter\n */export function applyFilter(cocktails,filter){return cocktails.filter(function(cocktail){return rules[filter.rule.toString()](cocktail,filter);});}/**\n * Apply multiple filters, one after the other\n * @param {*} cocktails\n * @param {*} filters\n */export function applyFilters(cocktails){var filters=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(!isArray(filters))filters=[filters];return compact(filters).reduce(function(acc,filter){return _toConsumableArray(applyFilter(acc,filter));},_toConsumableArray(cocktails));}// builds an array of filters based on the users current filter options.\nexport function filtersFromUserOptions(state){var filterOptions=state.filterOptions,otherState=_objectWithoutProperties(state,[\"filterOptions\"]);// Build initial filters based on the current \"activeFilters\"\nvar filters=filterOptions.activeFilters.map(function(filterRule){return buildFilter(filterRule)(filterOptions,otherState);});// Add in the special \"Name filter\", which is a filter but not in the\n// typical sense (so, it's not on the menu for example)\nif(filterOptions.nameFilter){filters.push({rule:\"nameIncludes\",searchText:filterOptions.nameFilter});}return filters;}","map":{"version":3,"sources":["/home/students/ge47qut/public_html/v2/react-speech/src/utilities/filter.js"],"names":["compact","isArray","buildFilter","rules","applyFilter","cocktails","filter","cocktail","rule","toString","applyFilters","filters","reduce","acc","filtersFromUserOptions","state","filterOptions","otherState","activeFilters","map","filterRule","nameFilter","push","searchText"],"mappings":"8WAAA,MAAOA,CAAAA,OAAP,KAAoB,gBAApB,CACA,MAAOC,CAAAA,OAAP,KAAoB,gBAApB,CACA,OAASC,WAAT,KAA4B,iBAA5B,CACA,MAAO,GAAKC,CAAAA,KAAZ,KAAuB,eAAvB,CAEA;;;;GAKA,MAAO,SAASC,CAAAA,WAAT,CAAqBC,SAArB,CAAgCC,MAAhC,CAAwC,CAC7C,MAAOD,CAAAA,SAAS,CAACC,MAAV,CAAiB,SAAAC,QAAQ,CAAI,CAClC,MAAOJ,CAAAA,KAAK,CAACG,MAAM,CAACE,IAAP,CAAYC,QAAZ,EAAD,CAAL,CAA8BF,QAA9B,CAAwCD,MAAxC,CAAP,CACD,CAFM,CAAP,CAGD,CAED;;;;GAKA,MAAO,SAASI,CAAAA,YAAT,CAAsBL,SAAtB,CAA+C,IAAdM,CAAAA,OAAc,2DAAJ,EAAI,CACpD,GAAI,CAACV,OAAO,CAACU,OAAD,CAAZ,CAAuBA,OAAO,CAAG,CAACA,OAAD,CAAV,CAEvB,MAAOX,CAAAA,OAAO,CAACW,OAAD,CAAP,CAAiBC,MAAjB,CACL,SAACC,GAAD,CAAMP,MAAN,4BAAqBF,WAAW,CAACS,GAAD,CAAMP,MAAN,CAAhC,GADK,oBAEDD,SAFC,EAAP,CAID,CAED;AACA,MAAO,SAASS,CAAAA,sBAAT,CAAgCC,KAAhC,CAAuC,IACpCC,CAAAA,aADoC,CACHD,KADG,CACpCC,aADoC,CAClBC,UADkB,0BACHF,KADG,oBAG5C;AACA,GAAMJ,CAAAA,OAAO,CAAGK,aAAa,CAACE,aAAd,CAA4BC,GAA5B,CAAgC,SAAAC,UAAU,CAAI,CAC5D,MAAOlB,CAAAA,WAAW,CAACkB,UAAD,CAAX,CAAwBJ,aAAxB,CAAuCC,UAAvC,CAAP,CACD,CAFe,CAAhB,CAIA;AACA;AACA,GAAID,aAAa,CAACK,UAAlB,CAA8B,CAC5BV,OAAO,CAACW,IAAR,CAAa,CACXd,IAAI,CAAE,cADK,CAEXe,UAAU,CAAEP,aAAa,CAACK,UAFf,CAAb,EAID,CAED,MAAOV,CAAAA,OAAP,CACD","sourcesContent":["import compact from \"lodash/compact\";\nimport isArray from \"lodash/isArray\";\nimport { buildFilter } from \"../filterConfig\";\nimport * as rules from \"./filterRules\";\n\n/**\n * Apply a single filter to a set of cocktails\n * @param {*} cocktails\n * @param {*} filter\n */\nexport function applyFilter(cocktails, filter) {\n  return cocktails.filter(cocktail => {\n    return rules[filter.rule.toString()](cocktail, filter);\n  });\n}\n\n/**\n * Apply multiple filters, one after the other\n * @param {*} cocktails\n * @param {*} filters\n */\nexport function applyFilters(cocktails, filters = []) {\n  if (!isArray(filters)) filters = [filters];\n\n  return compact(filters).reduce(\n    (acc, filter) => [...applyFilter(acc, filter)],\n    [...cocktails]\n  );\n}\n\n// builds an array of filters based on the users current filter options.\nexport function filtersFromUserOptions(state) {\n  const { filterOptions, ...otherState } = state;\n\n  // Build initial filters based on the current \"activeFilters\"\n  const filters = filterOptions.activeFilters.map(filterRule => {\n    return buildFilter(filterRule)(filterOptions, otherState);\n  });\n\n  // Add in the special \"Name filter\", which is a filter but not in the\n  // typical sense (so, it's not on the menu for example)\n  if (filterOptions.nameFilter) {\n    filters.push({\n      rule: \"nameIncludes\",\n      searchText: filterOptions.nameFilter\n    });\n  }\n\n  return filters;\n}\n"]},"metadata":{},"sourceType":"module"}